"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[594],{8283(e,n,s){s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-1","title":"Chapter 1: ROS 2 Fundamentals and Architecture","description":"Introduction to ROS 2 concepts and architecture for Physical AI systems","source":"@site/docs/module-1-robotic-nervous-system/chapter-1.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-1","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-1","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadyasir678/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/tree/main/docs/module-1-robotic-nervous-system/chapter-1.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Chapter 1: ROS 2 Fundamentals and Architecture","sidebar_position":1,"description":"Introduction to ROS 2 concepts and architecture for Physical AI systems"},"sidebar":"textbookSidebar","previous":{"title":"Introduction","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/introduction/intro"},"next":{"title":"Chapter 2: Nodes, Topics, and Message Passing","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-2"}}');var t=s(4848),r=s(8453);const o={title:"Chapter 1: ROS 2 Fundamentals and Architecture",sidebar_position:1,description:"Introduction to ROS 2 concepts and architecture for Physical AI systems"},c="Chapter 1: ROS 2 Fundamentals and Architecture",a={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Theory",id:"core-theory",level:2},{value:"Practical Example",id:"practical-example",level:2},{value:"Code Snippet",id:"code-snippet",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-1-ros-2-fundamentals-and-architecture",children:"Chapter 1: ROS 2 Fundamentals and Architecture"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the core concepts of ROS 2 and its architecture"}),"\n",(0,t.jsx)(n.li,{children:"Learn about nodes, topics, services, and actions in ROS 2"}),"\n",(0,t.jsx)(n.li,{children:"Explore how ROS 2 enables communication in Physical AI systems"}),"\n",(0,t.jsx)(n.li,{children:"Gain familiarity with ROS 2 tools and development practices"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Robot Operating System 2 (ROS 2) is a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robot platforms. For Physical AI systems, ROS 2 provides the communication infrastructure necessary for coordinating sensors, actuators, and AI algorithms."}),"\n",(0,t.jsx)(n.h2,{id:"core-theory",children:"Core Theory"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 is designed to be a flexible, distributed system that allows different components of a robot to communicate with each other. The core concepts include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes"}),": Processes that perform computation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Named buses over which nodes exchange messages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Synchronous request/response communication"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Goal-oriented communication with feedback"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),": Configuration values that can be set at runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lifecycle"}),": Management of node states"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 uses DDS (Data Distribution Service) as its underlying communication middleware, providing reliable, real-time communication between nodes."}),"\n",(0,t.jsx)(n.h2,{id:"practical-example",children:"Practical Example"}),"\n",(0,t.jsx)(n.p,{children:"Let's examine a simple ROS 2 publisher-subscriber pattern that demonstrates basic communication:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Publisher node example\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalPublisher(Node):\n    def __init__(self):\n        super().__init__('minimal_publisher')\n        self.publisher_ = self.create_publisher(String, 'topic', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n        self.i = 0\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello World: %d' % self.i\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n        self.i += 1\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Subscriber node example\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass MinimalSubscriber(Node):\n    def __init__(self):\n        super().__init__('minimal_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'topic',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info('I heard: \"%s\"' % msg.data)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"code-snippet",children:"Code Snippet"}),"\n",(0,t.jsx)(n.p,{children:"Complete the publisher-subscriber example by creating a launch file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# launch file example\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            package='demo_nodes_py',\n            executable='talker',\n            name='minimal_publisher',\n        ),\n        Node(\n            package='demo_nodes_py',\n            executable='listener',\n            name='minimal_subscriber',\n        ),\n    ])\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Common ROS 2 commands for running the example\nros2 run demo_nodes_py talker\nros2 run demo_nodes_py listener\nros2 topic list\nros2 topic echo /topic\n"})}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Conceptual Question"}),": Explain the difference between topics and services in ROS 2. When would you use each communication pattern?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Practical Exercise"}),": Create a simple ROS 2 package with a publisher that publishes sensor data (e.g., temperature readings) and a subscriber that logs this data."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Code Challenge"}),": Implement a ROS 2 service that accepts two numbers and returns their sum. Create both the service server and client nodes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Critical Thinking"}),": How does ROS 2's DDS-based communication architecture support the requirements of Physical AI systems that need real-time, reliable communication between components?"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter introduced the fundamental concepts of ROS 2, including its architecture, core communication patterns, and development tools. ROS 2 provides the communication infrastructure necessary for Physical AI systems to coordinate sensors, actuators, and AI algorithms effectively."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>o,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);