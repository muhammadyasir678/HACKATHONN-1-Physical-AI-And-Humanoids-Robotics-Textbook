"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[549],{2586(e,s,n){n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-2","title":"Chapter 2: Nodes, Topics, and Message Passing","description":"Understanding ROS 2 communication patterns: nodes, topics, and message passing","source":"@site/docs/module-1-robotic-nervous-system/chapter-2.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-2","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-2","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadyasir678/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/tree/main/docs/module-1-robotic-nervous-system/chapter-2.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Chapter 2: Nodes, Topics, and Message Passing","sidebar_position":2,"description":"Understanding ROS 2 communication patterns: nodes, topics, and message passing"},"sidebar":"textbookSidebar","previous":{"title":"Chapter 1: ROS 2 Fundamentals and Architecture","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-1"},"next":{"title":"Chapter 3: Services and Actions in ROS 2","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-3"}}');var o=n(4848),r=n(8453);const t={title:"Chapter 2: Nodes, Topics, and Message Passing",sidebar_position:2,description:"Understanding ROS 2 communication patterns: nodes, topics, and message passing"},a="Chapter 2: Nodes, Topics, and Message Passing",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Theory",id:"core-theory",level:2},{value:"Practical Example",id:"practical-example",level:2},{value:"Code Snippet",id:"code-snippet",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"chapter-2-nodes-topics-and-message-passing",children:"Chapter 2: Nodes, Topics, and Message Passing"})}),"\n",(0,o.jsx)(s.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Understand the fundamental ROS 2 communication concepts: nodes, topics, and messages"}),"\n",(0,o.jsx)(s.li,{children:"Learn how to create publishers and subscribers"}),"\n",(0,o.jsx)(s.li,{children:"Explore message passing patterns and data flow in ROS 2"}),"\n",(0,o.jsx)(s.li,{children:"Gain practical experience with ROS 2 tools for monitoring communication"}),"\n"]}),"\n",(0,o.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(s.p,{children:'ROS 2\'s communication system is built on a distributed architecture where processes called "nodes" communicate with each other through "topics". This publish-subscribe model enables loose coupling between components, allowing for flexible and scalable robot systems. Understanding nodes, topics, and message passing is crucial for developing robust Physical AI systems that require real-time communication between sensors, actuators, and processing units.'}),"\n",(0,o.jsx)(s.h2,{id:"core-theory",children:"Core Theory"}),"\n",(0,o.jsx)(s.p,{children:"The fundamental concepts in ROS 2 communication include:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Nodes"}),": Processes that perform computation and communication"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Topics"}),": Named buses over which nodes exchange messages"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Messages"}),": Data structures that are passed between nodes"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Publishers"}),": Nodes that send messages to topics"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"Subscribers"}),": Nodes that receive messages from topics"]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.strong,{children:"ROS Graph"}),": The network of nodes and their connections"]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"Communication in ROS 2 is asynchronous and follows a data-centric approach where publishers send messages to topics without knowing who will receive them, and subscribers receive messages from topics without knowing who sent them."}),"\n",(0,o.jsx)(s.h2,{id:"practical-example",children:"Practical Example"}),"\n",(0,o.jsx)(s.p,{children:"Let's examine a practical example of a publisher-subscriber pair with custom message types:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"# Custom message definition (my_robot_msgs/msg/SensorData.msg)\nfloat64 temperature\nfloat64 humidity\nint32 sensor_id\nstring sensor_name\n"})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"# Publisher node: sensor_publisher.py\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_msgs.msg import SensorData\nimport random\n\nclass SensorPublisher(Node):\n    def __init__(self):\n        super().__init__('sensor_publisher')\n        self.publisher = self.create_publisher(SensorData, 'sensor_data', 10)\n        timer_period = 1.0  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = SensorData()\n        msg.temperature = random.uniform(20.0, 30.0)\n        msg.humidity = random.uniform(30.0, 70.0)\n        msg.sensor_id = 1\n        msg.sensor_name = \"TemperatureHumiditySensor\"\n\n        self.publisher.publish(msg)\n        self.get_logger().info(f'Publishing: Temp={msg.temperature:.2f}, Humidity={msg.humidity:.2f}')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    sensor_publisher = SensorPublisher()\n\n    try:\n        rclpy.spin(sensor_publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        sensor_publisher.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"# Subscriber node: sensor_subscriber.py\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_msgs.msg import SensorData\n\nclass SensorSubscriber(Node):\n    def __init__(self):\n        super().__init__('sensor_subscriber')\n        self.subscription = self.create_subscription(\n            SensorData,\n            'sensor_data',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(\n            f'Received sensor data: {msg.sensor_name} (ID: {msg.sensor_id}) - '\n            f'Temperature: {msg.temperature:.2f}\xb0C, Humidity: {msg.humidity:.2f}%'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    sensor_subscriber = SensorSubscriber()\n\n    try:\n        rclpy.spin(sensor_subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        sensor_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(s.h2,{id:"code-snippet",children:"Code Snippet"}),"\n",(0,o.jsx)(s.p,{children:"Example of using ROS 2 command-line tools to monitor communication:"}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-bash",children:"# List all available topics\nros2 topic list\n\n# Echo messages from a specific topic\nros2 topic echo /sensor_data\n\n# Show information about a topic\nros2 topic info /sensor_data\n\n# Publish a message directly from command line\nros2 topic pub /sensor_data my_robot_msgs/SensorData \"{temperature: 25.0, humidity: 50.0, sensor_id: 1, sensor_name: 'ManualInput'}\"\n\n# Get topic statistics\nros2 topic hz /sensor_data\n"})}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{className:"language-python",children:"# Quality of Service (QoS) configuration for message passing\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\n\n# Configure QoS for real-time critical data\nqos_profile = QoSProfile(\n    depth=10,  # Number of messages to keep in queue\n    reliability=ReliabilityPolicy.RELIABLE,  # Ensure delivery\n    history=HistoryPolicy.KEEP_LAST  # Keep only the most recent messages\n)\n\n# Use QoS profile in publisher\npublisher = node.create_publisher(SensorData, 'sensor_data', qos_profile)\n\n# Use QoS profile in subscriber\nsubscription = node.create_subscription(\n    SensorData,\n    'sensor_data',\n    callback_function,\n    qos_profile\n)\n"})}),"\n",(0,o.jsx)(s.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(s.ol,{children:["\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Conceptual Question"}),": Explain the difference between ROS 1's centralized master-based architecture and ROS 2's decentralized approach. How does this affect communication reliability and scalability?"]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Practical Exercise"}),": Create a ROS 2 package with custom message types for a robot's sensor data. Implement a publisher that simulates a camera node and a subscriber that processes the camera data."]}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Code Challenge"}),': Design a communication system with multiple publishers and subscribers on the same topic. Implement a system where different sensor nodes publish to a common "robot_sensors" topic and a fusion node aggregates the data.']}),"\n"]}),"\n",(0,o.jsxs)(s.li,{children:["\n",(0,o.jsxs)(s.p,{children:[(0,o.jsx)(s.strong,{children:"Critical Thinking"}),": How do Quality of Service (QoS) policies in ROS 2 affect the reliability of Physical AI systems? Discuss the trade-offs between reliability and real-time performance in robot communication."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(s.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(s.p,{children:"This chapter explored the fundamental ROS 2 communication patterns: nodes, topics, and message passing. We learned how to create publishers and subscribers, work with custom message types, and use ROS 2 tools for monitoring communication. The publish-subscribe model provides a flexible, scalable communication framework essential for Physical AI systems that need to coordinate multiple sensors, actuators, and processing units."})]})}function m(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,s,n){n.d(s,{R:()=>t,x:()=>a});var i=n(6540);const o={},r=i.createContext(o);function t(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);