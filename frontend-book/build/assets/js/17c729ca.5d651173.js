"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[110],{8453(e,n,a){a.d(n,{R:()=>i,x:()=>s});var r=a(6540);const t={},o=r.createContext(t);function i(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},8656(e,n,a){a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-4","title":"Chapter 4: Parameter Management and Launch Systems","description":"Managing configuration and launching ROS 2 systems with parameters and launch files","source":"@site/docs/module-1-robotic-nervous-system/chapter-4.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-4","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-4","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadyasir678/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/tree/main/docs/module-1-robotic-nervous-system/chapter-4.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Chapter 4: Parameter Management and Launch Systems","sidebar_position":4,"description":"Managing configuration and launching ROS 2 systems with parameters and launch files"},"sidebar":"textbookSidebar","previous":{"title":"Chapter 3: Services and Actions in ROS 2","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-3"},"next":{"title":"Chapter 5: ROS 2 Tools and Debugging","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-5"}}');var t=a(4848),o=a(8453);const i={title:"Chapter 4: Parameter Management and Launch Systems",sidebar_position:4,description:"Managing configuration and launching ROS 2 systems with parameters and launch files"},s="Chapter 4: Parameter Management and Launch Systems",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Theory",id:"core-theory",level:2},{value:"Practical Example",id:"practical-example",level:2},{value:"Code Snippet",id:"code-snippet",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-4-parameter-management-and-launch-systems",children:"Chapter 4: Parameter Management and Launch Systems"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand ROS 2 parameter management for configuration"}),"\n",(0,t.jsx)(n.li,{children:"Learn to create and use launch files for system startup"}),"\n",(0,t.jsx)(n.li,{children:"Explore parameter declaration, access, and dynamic reconfiguration"}),"\n",(0,t.jsx)(n.li,{children:"Gain experience with launch arguments and conditional execution"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Effective parameter management and system launching are critical for deploying and operating complex Physical AI systems. ROS 2 provides robust mechanisms for managing configuration parameters and orchestrating the startup of multiple nodes. Parameters allow for runtime configuration without recompilation, while launch files enable the coordinated startup of complex multi-node systems. These tools are essential for creating maintainable, configurable, and deployable Physical AI applications."}),"\n",(0,t.jsx)(n.h2,{id:"core-theory",children:"Core Theory"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 parameter and launch systems include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),": Configuration values that can be set at runtime"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parameter Descriptors"}),": Constraints and metadata for parameters"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch Files"}),": XML/YAML/Python files that specify how to launch multiple nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Launch Arguments"}),": Dynamic values passed to launch files"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Composable Nodes"}),": Nodes that can be loaded into a single process container"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Parameters in ROS 2 are strongly typed and can be:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Declared with constraints (min, max, range, etc.)"}),"\n",(0,t.jsx)(n.li,{children:"Set at node startup or changed dynamically"}),"\n",(0,t.jsx)(n.li,{children:"Accessed programmatically from within nodes"}),"\n",(0,t.jsx)(n.li,{children:"Loaded from configuration files"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Launch files can specify:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Which nodes to run"}),"\n",(0,t.jsx)(n.li,{children:"Their parameters"}),"\n",(0,t.jsx)(n.li,{children:"Their remappings"}),"\n",(0,t.jsx)(n.li,{children:"Their required dependencies"}),"\n",(0,t.jsx)(n.li,{children:"Conditional execution based on arguments"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"practical-example",children:"Practical Example"}),"\n",(0,t.jsx)(n.p,{children:"Let's examine parameter declaration and usage in a ROS 2 node:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Parameter management example: robot_controller.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rcl_interfaces.msg import ParameterDescriptor\nfrom rcl_interfaces.msg import ParameterType\n\nclass RobotController(Node):\n    def __init__(self):\n        super().__init__('robot_controller')\n\n        # Declare parameters with descriptors\n        self.declare_parameter(\n            'max_velocity',\n            1.0,\n            ParameterDescriptor(\n                name='max_velocity',\n                type=ParameterType.PARAMETER_DOUBLE,\n                description='Maximum velocity for robot movement',\n                additional_constraints='Must be positive',\n                floating_point_range=[Parameter.FloatingPointRange(from_value=0.0, to_value=10.0, step=0.1)]\n            )\n        )\n\n        self.declare_parameter(\n            'robot_name',\n            'default_robot',\n            ParameterDescriptor(\n                name='robot_name',\n                type=ParameterType.PARAMETER_STRING,\n                description='Name of the robot',\n                additional_constraints='Alphanumeric characters only'\n            )\n        )\n\n        # Get parameter values\n        self.max_velocity = self.get_parameter('max_velocity').value\n        self.robot_name = self.get_parameter('robot_name').value\n\n        self.get_logger().info(f'Robot {self.robot_name} initialized with max velocity: {self.max_velocity}')\n\n        # Set up parameter change callback\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n    def parameter_callback(self, params):\n        for param in params:\n            if param.name == 'max_velocity' and param.type_ == Parameter.Type.PARAMETER_DOUBLE:\n                if 0.0 <= param.value <= 10.0:\n                    self.max_velocity = param.value\n                    self.get_logger().info(f'Max velocity updated to: {param.value}')\n                    return SetParametersResult(successful=True)\n                else:\n                    self.get_logger().error('Max velocity must be between 0.0 and 10.0')\n                    return SetParametersResult(successful=False)\n        return SetParametersResult(successful=True)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    robot_controller = RobotController()\n\n    try:\n        rclpy.spin(robot_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        robot_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"code-snippet",children:"Code Snippet"}),"\n",(0,t.jsx)(n.p,{children:"Example launch file in Python:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Launch file: robot_system.launch.py\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\nfrom launch.substitutions import TextSubstitution\n\ndef generate_launch_description():\n    # Declare launch arguments\n    robot_name_launch_arg = DeclareLaunchArgument(\n        'robot_name',\n        default_value='my_robot',\n        description='Name of the robot'\n    )\n\n    max_velocity_launch_arg = DeclareLaunchArgument(\n        'max_velocity',\n        default_value='1.0',\n        description='Maximum velocity for the robot'\n    )\n\n    # Get launch configuration values\n    robot_name = LaunchConfiguration('robot_name')\n    max_velocity = LaunchConfiguration('max_velocity')\n\n    # Define robot controller node\n    robot_controller_node = Node(\n        package='my_robot_package',\n        executable='robot_controller',\n        name='robot_controller',\n        parameters=[\n            {\n                'robot_name': robot_name,\n                'max_velocity': max_velocity\n            }\n        ],\n        remappings=[\n            ('/cmd_vel', '/robot1/cmd_vel'),\n            ('/odom', '/robot1/odom')\n        ]\n    )\n\n    # Define sensor node\n    sensor_node = Node(\n        package='my_robot_package',\n        executable='sensor_driver',\n        name='sensor_driver',\n        parameters=[\n            {\n                'sensor_range': 10.0,\n                'update_rate': 10.0\n            }\n        ]\n    )\n\n    return LaunchDescription([\n        robot_name_launch_arg,\n        max_velocity_launch_arg,\n        robot_controller_node,\n        sensor_node\n    ])\n"})}),"\n",(0,t.jsx)(n.p,{children:"YAML parameter file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'# Parameter file: config/robot_params.yaml\n/**:  # Applies to all nodes\n  ros__parameters:\n    robot_name: "configured_robot"\n    max_velocity: 2.0\n    safety_margin: 0.5\n\nrobot_controller:  # Applies to robot_controller node only\n  ros__parameters:\n    control_frequency: 50.0\n    acceleration_limit: 1.5\n\nsensor_driver:\n  ros__parameters:\n    sensor_range: 5.0\n    update_rate: 20.0\n'})}),"\n",(0,t.jsx)(n.p,{children:"Command-line examples for parameter management:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# List parameters of a node\nros2 param list /robot_controller\n\n# Get a specific parameter\nros2 param get /robot_controller max_velocity\n\n# Set a parameter\nros2 param set /robot_controller max_velocity 2.5\n\n# Load parameters from a file\nros2 param load /robot_controller config/robot_params.yaml\n\n# Save current parameters to a file\nros2 param dump /robot_controller --output current_params.yaml\n\n# Launch with arguments\nros2 launch my_robot_package robot_system.launch.py robot_name:=test_robot max_velocity:=3.0\n"})}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Conceptual Question"}),": Explain the advantages of using launch files over manually starting individual nodes. How do launch files improve the maintainability of Physical AI systems?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Practical Exercise"}),": Create a ROS 2 package with a node that declares multiple parameters with different types and constraints. Create a launch file that starts the node with parameter values loaded from a YAML file."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Code Challenge"}),": Design a launch system that can conditionally start different sets of nodes based on launch arguments. Create a launch file that can start either a simulation or real robot configuration."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Critical Thinking"}),": How do ROS 2 parameters compare to environment variables or configuration files in terms of flexibility and runtime reconfiguration? What are the performance implications of using parameters in real-time systems?"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter explored ROS 2's parameter management and launch systems, which are essential for configuring and deploying complex Physical AI systems. We learned how to declare and manage parameters with constraints, create launch files for coordinated system startup, and use launch arguments for dynamic configuration. These tools enable the creation of maintainable, configurable, and deployable Physical AI applications that can adapt to different environments and requirements."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}}}]);