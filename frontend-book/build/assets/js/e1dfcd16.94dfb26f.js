"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook=globalThis.webpackChunkphysical_ai_humanoid_robotics_textbook||[]).push([[59],{5753(e,n,s){s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"module-1-robotic-nervous-system/chapter-3","title":"Chapter 3: Services and Actions in ROS 2","description":"Understanding ROS 2 services and actions for synchronous and goal-oriented communication","source":"@site/docs/module-1-robotic-nervous-system/chapter-3.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/chapter-3","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-3","draft":false,"unlisted":false,"editUrl":"https://github.com/muhammadyasir678/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/tree/main/docs/module-1-robotic-nervous-system/chapter-3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Chapter 3: Services and Actions in ROS 2","sidebar_position":3,"description":"Understanding ROS 2 services and actions for synchronous and goal-oriented communication"},"sidebar":"textbookSidebar","previous":{"title":"Chapter 2: Nodes, Topics, and Message Passing","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-2"},"next":{"title":"Chapter 4: Parameter Management and Launch Systems","permalink":"/HACKATHONN-1-Physical-AI-And-Humanoids-Robotics-Textbook/docs/module-1-robotic-nervous-system/chapter-4"}}');var t=s(4848),i=s(8453);const r={title:"Chapter 3: Services and Actions in ROS 2",sidebar_position:3,description:"Understanding ROS 2 services and actions for synchronous and goal-oriented communication"},a="Chapter 3: Services and Actions in ROS 2",c={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Core Theory",id:"core-theory",level:2},{value:"Practical Example",id:"practical-example",level:2},{value:"Code Snippet",id:"code-snippet",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-3-services-and-actions-in-ros-2",children:"Chapter 3: Services and Actions in ROS 2"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand ROS 2 services for synchronous request/response communication"}),"\n",(0,t.jsx)(n.li,{children:"Learn about ROS 2 actions for goal-oriented, long-running operations"}),"\n",(0,t.jsx)(n.li,{children:"Explore when to use services vs. actions vs. topics"}),"\n",(0,t.jsx)(n.li,{children:"Gain practical experience with service and action clients and servers"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"While topics enable asynchronous communication in ROS 2, services and actions provide mechanisms for synchronous communication and goal-oriented operations. Services offer request/response patterns similar to remote procedure calls, while actions are designed for long-running operations that require feedback and the ability to cancel. These communication patterns are essential for Physical AI systems that need to coordinate complex, multi-step tasks and ensure completion of critical operations."}),"\n",(0,t.jsx)(n.h2,{id:"core-theory",children:"Core Theory"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 provides three primary communication patterns:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Topics"}),": Asynchronous, many-to-many communication via publish/subscribe"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": Synchronous, request/response communication for immediate results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": Goal-oriented communication for long-running operations with feedback"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Services are appropriate for operations that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Have a clear request and response"}),"\n",(0,t.jsx)(n.li,{children:"Complete quickly"}),"\n",(0,t.jsx)(n.li,{children:"Don't require intermediate feedback"}),"\n",(0,t.jsx)(n.li,{children:"Need guaranteed delivery and response"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Actions are appropriate for operations that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Take a long time to complete"}),"\n",(0,t.jsx)(n.li,{children:"Require intermediate feedback"}),"\n",(0,t.jsx)(n.li,{children:"Need to be cancellable"}),"\n",(0,t.jsx)(n.li,{children:"Have status updates during execution"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"practical-example",children:"Practical Example"}),"\n",(0,t.jsx)(n.p,{children:"Let's examine examples of services and actions in ROS 2:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Service definition: my_robot_msgs/srv/MoveRobot.srv\nfloat64 x\nfloat64 y\nfloat64 theta\n---\nbool success\nstring message\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Service server: move_robot_server.py\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_msgs.srv import MoveRobot\n\nclass MoveRobotService(Node):\n    def __init__(self):\n        super().__init__('move_robot_service')\n        self.srv = self.create_service(MoveRobot, 'move_robot', self.move_robot_callback)\n\n    def move_robot_callback(self, request, response):\n        self.get_logger().info(f'Received request to move to: ({request.x}, {request.y}, {request.theta})')\n\n        # Simulate robot movement\n        success = self.execute_movement(request.x, request.y, request.theta)\n\n        response.success = success\n        response.message = \"Movement completed successfully\" if success else \"Movement failed\"\n\n        return response\n\n    def execute_movement(self, x, y, theta):\n        # Simulate movement execution\n        self.get_logger().info(f'Executing movement to ({x}, {y}, {theta})')\n        # In a real robot, this would control actual motors\n        return True  # Simulate success\n\ndef main(args=None):\n    rclpy.init(args=args)\n    move_robot_service = MoveRobotService()\n\n    try:\n        rclpy.spin(move_robot_service)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        move_robot_service.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Service client: move_robot_client.py\nimport rclpy\nfrom rclpy.node import Node\nfrom my_robot_msgs.srv import MoveRobot\n\nclass MoveRobotClient(Node):\n    def __init__(self):\n        super().__init__('move_robot_client')\n        self.cli = self.create_client(MoveRobot, 'move_robot')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n    def send_request(self, x, y, theta):\n        request = MoveRobot.Request()\n        request.x = x\n        request.y = y\n        request.theta = theta\n        self.future = self.cli.call_async(request)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    move_robot_client = MoveRobotClient()\n\n    response = move_robot_client.send_request(1.0, 2.0, 0.5)\n    move_robot_client.get_logger().info(f'Result: {response.success}, {response.message}')\n\n    move_robot_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"code-snippet",children:"Code Snippet"}),"\n",(0,t.jsx)(n.p,{children:"Example of an action server and client:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Action definition: my_robot_msgs/action/Navigation.action\n# Goal: float64 x, float64 y\n# Result: bool success, string message\n# Feedback: float64 distance_to_goal\n\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\n\n# Action server implementation\nclass NavigationActionServer(Node):\n    def __init__(self):\n        super().__init__('navigation_action_server')\n        self._action_server = ActionServer(\n            self,\n            Navigation,\n            'navigate_to_pose',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup())\n\n    def goal_callback(self, goal_request):\n        self.get_logger().info('Received navigation goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing navigation goal...')\n\n        # Simulate navigation process\n        feedback_msg = Navigation.Feedback()\n        result = Navigation.Result()\n\n        # Simulate progress toward goal\n        for i in range(10):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result.success = False\n                result.message = 'Goal canceled'\n                return result\n\n            # Simulate progress\n            feedback_msg.distance_to_goal = 10.0 - i\n            goal_handle.publish_feedback(feedback_msg)\n            time.sleep(1)  # Simulate work\n\n        goal_handle.succeed()\n        result.success = True\n        result.message = 'Navigation completed successfully'\n        return result\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# Action client implementation\nfrom rclpy.action import ActionClient\nfrom rclpy.duration import Duration\n\nclass NavigationActionClient(Node):\n    def __init__(self):\n        super().__init__('navigation_action_client')\n        self._action_client = ActionClient(self, Navigation, 'navigate_to_pose')\n\n    def send_goal(self, x, y):\n        goal_msg = Navigation.Goal()\n        goal_msg.x = x\n        goal_msg.y = y\n\n        self._action_client.wait_for_server()\n        self._send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback)\n\n        self._send_goal_future.add_done_callback(self.goal_response_callback)\n\n    def goal_response_callback(self, future):\n        goal_handle = future.result()\n        if not goal_handle.accepted:\n            self.get_logger().info('Goal rejected')\n            return\n\n        self.get_logger().info('Goal accepted')\n        self._get_result_future = goal_handle.get_result_async()\n        self._get_result_future.add_done_callback(self.get_result_callback)\n\n    def feedback_callback(self, feedback_msg):\n        self.get_logger().info(f'Distance to goal: {feedback_msg.feedback.distance_to_goal}')\n\n    def get_result_callback(self, future):\n        result = future.result().result\n        self.get_logger().info(f'Result: {result.success}, {result.message}')\n"})}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Conceptual Question"}),": Compare and contrast the use of topics, services, and actions in ROS 2. When would you use each communication pattern in a Physical AI system?"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Practical Exercise"}),": Create a ROS 2 package with custom service and action definitions. Implement a service that calculates the distance between two points and an action that moves a robot to a target position with feedback."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Code Challenge"}),": Design a robot system where multiple nodes coordinate using different communication patterns. Implement a system with a navigation service, a mapping action, and sensor data topics."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Critical Thinking"}),": How do services and actions impact the real-time performance of Physical AI systems? Discuss the trade-offs between synchronous communication and system responsiveness."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter covered ROS 2's synchronous communication patterns: services for request/response interactions and actions for goal-oriented operations. We learned when to use each pattern and implemented practical examples of both. Services and actions provide essential communication mechanisms for Physical AI systems that need to coordinate complex, multi-step tasks and ensure completion of critical operations with feedback and cancellation capabilities."})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>r,x:()=>a});var o=s(6540);const t={},i=o.createContext(t);function r(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);